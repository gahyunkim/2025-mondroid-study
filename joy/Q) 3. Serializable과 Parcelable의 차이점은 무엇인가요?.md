# Q) 3. Serializable과 Parcelable의 차이점은 무엇인가요?

### 직렬화란?

- Java의 직렬화 → 어떤 객체를 Byte로 변경하는 것,
- 직렬화란 객체를 바이트스트림으로 변환하여 파일로 저장하거나 네트워크를 통해 전송하거나, 컴포넌트간의 전달이 가능하도록 만드는 과정이다.
- 역직렬화 → 직렬화된 바이트 데이터를 다시 객체ㅗㄹ 복원하는 과정

## Serializable

- java 표준 인터페이스로, 구현이 간단하지만 reflection 기반으로 동작하기 때문에, 성능이 낮고 GC의 부하가 크다.
- 간단하게 객체를 빠르고 손쉽게 바이트로 변환할 수 있다.

### Reflection

- 런타임에 클래스, 메서드, 필드 등의 정보를 동적으로 조사하고 조작할 수 있게해주는 기능이다.
- 컴파일 시점에는 몰랐던 객체의 내부 구조를 실행중에 들여다보고 수정하거나 호출할 수 있는 기능을 말한다.
- 하지만, 리플렉션은 런타임 시점에 접근 제어를 우회하거나 내부적으로 데이터를 탐색해야하기 때문에 성능이 떨어지고, GC의 부하가 커진다.

### GC(Garbage Colllector)란?

- 더 이상 사용하지 않는 객체를 메모리에서 자동으로 해제해주는 기능이다.
- 자바와 안드로이드 개발자가 delete를 명시적으로 호출하지 않아도 GC가 주기적으로 메모리를 정리한다.

### Reflection은 왜 GC에 부하를 주는가?

- reflection은 런타임에 동적으로 객체를 생성한다. 이때 일반적인 생성자보다 무겁고 추가적인 메타정보 객체를 함께 생성한다는 문제가 있다.
- 메타 데이터와 내부 구조 정보를 동적으로 유지한다. → 클래스 구조를 담고 있는 객체들이 별도로 생성되고 메모리에 오래 살아남는다.
- 따라서 이렇게 많은 객체를 생성하고, 내부 구조 정보를 유지하는 등의 일을 하기 때문에 GC 대상의 객체가 많아지고 ,GC횟수도 잦아져서 부하가 커지는 것이다.

## Parcelable

- 안드로이드 전용 인터페이스로, 직접 읽고 쓰는 로직을 구현해야하지만, 더 빠르고 효율적이다.
- 최근에는 @Parcelable 어노테이션을 사용하면, 간단하게 로직을 작성하지 않아도 되도록 적용되었다.
- 또한, Reflection을 사용하지 않는다. → 사용자가 직접 직렬화 처리방식을 명시적으로 작성한다.
    - 다만, 사용자가 명시적으로 작성하기 때문에 보일러 플레이트 코드가 발생하고 유지보수 하기 힘들어진다는 단점이 있음
- GC의 동작으로 인해, Parcelable이 성능적으로 더 좋다는 것을 확인할 수 있기도 함.

### Parcel이란?

- 짐을 싸듯이 객체를 싸는 클래스이다.
- parcel 클래스는 직렬화 시에 Container의 역할을 하는 클래스로 말그대로
- 안드로이드는 프로세스간의 통신을 위해서 bundle 클래스를 사용하는데, 이러한 bundle class는 map으로 key, value가 있는 형태이다.
    - 간단한 int, String과 같은 데이터는 넘길 수 있지만 kotlin의 데이터클래스는 내부에 많은 데이터가 있어서 value로 입력하는 것이 어렵다.
    - 이런걸 개선하기 위한 것이 parcel이다.

## IPC(Inter-Process Communication)란?

- 서로 다른 프로세스에서 실행중인 컴포넌트들 간에 데이터를 주고받는 기술 또는 방법을 의미한다. 즉, 프로세스간의 통신 수단이다.

### 안드로이드에서 사용하는 IPC 방법들

- Intent: 가장 기본적으로 IPC, 액티비티/서비스 호출시에 사용함
- Binder: Android 고유의 고성능 IPC 메커니즘
- Messenger: Handler 기반의 IPC, 간단한 메시지 교환에 적합
- ContentProvider: 데이터 공유 전용의 IPC 방식

⇒ 결론적으로 IPC는 서로 다른 프로세스 간에 데이터를 주고받기 위한 메커니즘이며 안드로이드에서는 주로 Binding, Messenger, ContentProvider등을 통해서 다양한 형태로 구현된다.
